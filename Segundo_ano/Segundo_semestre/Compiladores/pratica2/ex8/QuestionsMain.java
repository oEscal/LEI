import java.util.List;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;
import java.util.Collections;
import java.io.File;
import java.io.FileInputStream;
import java.util.Scanner;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;

public class QuestionsMain {

   public static void main(String[] args) throws Exception {

      if (args.length < 3 || !isNumber(args[2])){

         System.err.println("Error in args!");
         System.exit(1);
      }

      // read file
      FileInputStream file = new FileInputStream(args[0]);

      /*AUTOGENERATED CODE*/
      // create a CharStream that reads from standard input:
      CharStream input = CharStreams.fromStream(file);
      // create a lexer that feeds off of input CharStream:
      QuestionsLexer lexer = new QuestionsLexer(input);
      // create a buffer of tokens pulled from the lexer:
      CommonTokenStream tokens = new CommonTokenStream(lexer);
      // create a parser that feeds off the tokens buffer:
      QuestionsParser parser = new QuestionsParser(tokens);
      // replace error listener:
      //parser.removeErrorListeners(); // remove ConsoleErrorListener
      //parser.addErrorListener(new ErrorHandlingListener());
      // begin parsing at program rule:
      ParseTree tree = parser.program();
      MyQuestionsVisitor visitor = new MyQuestionsVisitor();
      if (parser.getNumberOfSyntaxErrors() == 0) {
         // print LISP-style tree:
         // System.out.println(tree.toStringTree(parser));
         visitor.visit(tree);
      }


      // questions
      Map<String, List<QandA>> questions = visitor.getQuestions();

      try {

         List<QandA> q_and_a = questions.get(args[1]);
         List<QandA> right_answers = new ArrayList<>();
         List<QandA> wrong_answers = new ArrayList<>();

         System.out.println("- " + q_and_a.remove(0).getText());

         q_and_a.forEach(answer -> {

            if (((Answer) answer).getPonctuation() == 100)
               right_answers.add(answer);
            else
               wrong_answers.add(answer);
         });

         Collections.shuffle(right_answers);
         Collections.shuffle(wrong_answers);

         boolean contains_right = false;
         Map<String, Answer> all_answers = new HashMap<>();
         for (int i = 0; i < Integer.parseInt(args[2]); i++){

            Answer current_answer;

            if (i == Integer.parseInt(args[2]) - 1 && !contains_right 
               || Math.random() < 0.5 && right_answers.size() > 0) {
               current_answer = (Answer) right_answers.remove(0);
               contains_right = true;
            }
            else 
               current_answer = (Answer) wrong_answers.remove(0);

            System.out.println("\t" + (char) ((int) 'a' + i) + ") " 
                                 + current_answer.getAnswer());
            all_answers.put((char) ((int) 'a' + i) + "", current_answer);
         }
         
         Scanner in = new Scanner (System.in);
         System.out.print("Respost: ");
         String a = in.next();

         System.out.println("Ponctuation: " + all_answers.get(a).getPonctuation());

      } catch(Exception e) {
         
         System.err.println("The given question doesn't exists!");
         System.exit(1);
      }
   }

   private static boolean isNumber(String word) {
      return word.chars().allMatch(Character :: isDigit);
   }
}
